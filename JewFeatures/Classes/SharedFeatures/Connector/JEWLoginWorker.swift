//
//  LoginWorker.swift
//  InvestScopio
//
//  Created by Joao Medeiros Pereira on 12/06/19.
//  Copyright (c) 2019 Joao Medeiros Pereira. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Alamofire

typealias PopMessageLoginInfo = (title: String, message: String)
typealias SuccessLoginHandler = (JEWUserModel) -> ()
typealias ErrorLoginHandler = (_ titleError:String,_ messageError:String, _ shouldHideAutomatically:Bool, _ popupType:JEWPopupMessageType) ->()
typealias SuccessRefreshTokenHandler = (JEWAccessModel) -> ()
typealias ErrorRefreshTokenHandler = (_ titleError:String,_ messageError:String, _ shouldHideAutomatically:Bool, _ popupType:JEWPopupMessageType) -> ()
typealias LogoutHandler = () -> ()


protocol JEWLoginWorkerProtocol {
    func login(withTextFields textFields: [JEWFloatingTextField], successCompletionHandler: @escaping(SuccessLoginHandler), errorCompletionHandler:@escaping(ErrorLoginHandler))
    func loginAsAdmin(successCompletionHandler: @escaping(SuccessLoginHandler), errorCompletionHandler:@escaping(ErrorLoginHandler))
    func loggedUser(withEmail email: String, security: String, successCompletionHandler: @escaping(SuccessLoginHandler), errorCompletionHandler:@escaping(ErrorLoginHandler))
    func refreshToken(successRefreshCompletionHandler: @escaping (SuccessRefreshTokenHandler), errorRefreshCompletionHandler: @escaping (ErrorRefreshTokenHandler))
    func logout(logoutHandler: @escaping(LogoutHandler))
}

class JEWLoginWorker: NSObject,JEWLoginWorkerProtocol {
    func login(withTextFields textFields: [JEWFloatingTextField], successCompletionHandler: @escaping(SuccessLoginHandler), errorCompletionHandler:@escaping(ErrorLoginHandler)) {
        if let textFieldsError = check(withTextFields: textFields) {
            errorCompletionHandler(textFieldsError.title, textFieldsError.message, true, .error)
            return
        }
    }
    
    func loginAsAdmin(successCompletionHandler: @escaping (SuccessLoginHandler), errorCompletionHandler: @escaping (ErrorLoginHandler)) {
        login(email: "admin@admin.com", password: "admin@22151515", successCompletionHandler: { (user) in
            successCompletionHandler(user)
        }) { (title, message, shouldHideAutomatically, popupType) in
            errorCompletionHandler(title, message, shouldHideAutomatically, popupType)
        }
    }
    
    private func login(email: String, password: String, successCompletionHandler: @escaping (SuccessLoginHandler), errorCompletionHandler: @escaping (ErrorLoginHandler)) {
    }
    
    func loggedUser(withEmail email: String, security: String, successCompletionHandler: @escaping (SuccessLoginHandler), errorCompletionHandler: @escaping (ErrorLoginHandler)) {
        let userRememberLoggedModel = JEWUserModel(email: email, uid: security)
        signInInvestScopioAPI(user: userRememberLoggedModel, successLoginHandler: { (userAPI) in
            successCompletionHandler(userAPI)
        }, errorCompletionHandler: { (title, message, shouldHideAutomatically, popupType) in
            errorCompletionHandler(title, message, shouldHideAutomatically, popupType)
        })
    }
    
    func signInInvestScopioAPI(user: JEWUserModel, successLoginHandler: @escaping(SuccessLoginHandler), errorCompletionHandler:@escaping(ErrorLoginHandler)) {
        let headers = ["Content-Type": "application/json"]
        
        let userRequest = JEWUserRequest(email: user.email, password: user.uid)
        
        JEWConnector.connector.request(withRoute: ConnectorRoutes.signin, method: .post, parameters: userRequest, responseClass: JEWAccessModel.self, headers: headers, shouldRetry: true, successCompletion: { (decodable) in
            
            var userResponse = user
            if let access = decodable as? JEWAccessModel {
                userResponse.access = access
            }
            successLoginHandler(userResponse)
        }) { (error) in
            errorCompletionHandler(error.title, error.message, true, .error)
        }
        
    }
    
    private func check(withTextFields textFields:[JEWFloatingTextField]) -> PopMessageLoginInfo? {
        if let emailTextField = textFields.filter({$0.typeTextField == .email}).first {
            if emailTextField.floatingTextField.text?.isValidEmail() == false {
                if emailTextField.required {
                    emailTextField.hasError = true
                    emailTextField.floatingTextField.becomeFirstResponder()
                }
                return PopMessageLoginInfo(title: emailTextField.typeTextField?.getTitleMessageInfo() ?? "", message: emailTextField.typeTextField?.getMessageInfo() ?? "")
            }
            emailTextField.hasError = false
        }
        return nil
    }
    
    func refreshToken(successRefreshCompletionHandler: @escaping (SuccessRefreshTokenHandler), errorRefreshCompletionHandler: @escaping (ErrorRefreshTokenHandler)) {
        guard let headers = ["Content-Type": "application/json", "Authorization": JEWSession.session.user?.access?.accessToken] as? HTTPHeaders else {
            errorRefreshCompletionHandler(JEWConstants.RefreshErrors.title.rawValue,JEWConstants.RefreshErrors.message.rawValue, true, .error)
            return
        }
        guard let refreshToken = JEWSession.session.user?.access?.refreshToken else {
            errorRefreshCompletionHandler(JEWConstants.RefreshErrors.title.rawValue,JEWConstants.RefreshErrors.message.rawValue, true, .error)
            return
        }
        let refreshTokenRequest = JEWRefreshTokenRequest.init(refreshToken: refreshToken)
        JEWConnector.connector.request(withRoute: ConnectorRoutes.refreshToken, method: .post, parameters: refreshTokenRequest, responseClass: JEWAccessModel.self, headers: headers, successCompletion: { (decodable) in
            if let access = decodable as? JEWAccessModel {
                successRefreshCompletionHandler(access)
                return
            }
            errorRefreshCompletionHandler(JEWConstants.RefreshErrors.title.rawValue,JEWConstants.RefreshErrors.message.rawValue, true, .error)
        }) { (error) in
            errorRefreshCompletionHandler(JEWConstants.RefreshErrors.title.rawValue,JEWConstants.RefreshErrors.message.rawValue, true, .error)
        }
    }
    
    
    func logout(logoutHandler: @escaping(LogoutHandler)) {
        guard let headers = ["Content-Type": "application/json", "Authorization": JEWSession.session.user?.access?.accessToken] as? HTTPHeaders else {
            logoutHandler()
            return
        }
        JEWConnector.connector.request(withRoute: ConnectorRoutes.logout, method: .post, responseClass: JEWLogoutResponse.self, headers: headers, successCompletion: { (decodable) in
            if let logout = decodable as? JEWLogoutResponse {
                print(logout)
            }
            logoutHandler()
        }) { (error) in
            logoutHandler()
        }
    }
}
